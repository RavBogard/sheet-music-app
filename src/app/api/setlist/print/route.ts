import { NextResponse } from "next/server"
import { PDFDocument, rgb, StandardFonts } from "pdf-lib"
import { DriveClient } from "@/lib/google-drive"

interface PrintTrack {
    title: string
    key: string
    notes: string
    fileId?: string
}

interface PrintRequest {
    title: string
    date: string
    musicianName?: string
    eventName?: string
    tracks: PrintTrack[]
}

export async function POST(request: Request) {
    try {
        const body: PrintRequest = await request.json()
        const { title, date, musicianName, eventName, tracks } = body

        if (!title || !tracks || tracks.length === 0) {
            return NextResponse.json({ error: "Missing title or tracks" }, { status: 400 })
        }

        const drive = new DriveClient()

        // 1. Create the merged PDF document
        const mergedPdf = await PDFDocument.create()

        // 2. Create cover page
        const coverPage = mergedPdf.addPage([612, 792]) // Letter size
        const helveticaBold = await mergedPdf.embedFont(StandardFonts.HelveticaBold)
        const helvetica = await mergedPdf.embedFont(StandardFonts.Helvetica)

        const { width, height } = coverPage.getSize()

        // Title
        coverPage.drawText(title, {
            x: 50,
            y: height - 80,
            size: 32,
            font: helveticaBold,
            color: rgb(0, 0, 0),
        })

        // Date
        coverPage.drawText(date, {
            x: 50,
            y: height - 120,
            size: 14,
            font: helvetica,
            color: rgb(0.4, 0.4, 0.4),
        })

        // Event name (if provided)
        let yOffset = height - 150
        if (eventName) {
            coverPage.drawText(eventName, {
                x: 50,
                y: yOffset,
                size: 14,
                font: helvetica,
                color: rgb(0.4, 0.4, 0.4),
            })
            yOffset -= 25
        }

        // Musician name (if provided)
        if (musicianName) {
            coverPage.drawText(`Prepared for: ${musicianName}`, {
                x: 50,
                y: yOffset,
                size: 14,
                font: helveticaBold,
                color: rgb(0, 0, 0),
            })
            yOffset -= 30
        }

        // Divider line
        yOffset -= 15
        coverPage.drawLine({
            start: { x: 50, y: yOffset },
            end: { x: width - 50, y: yOffset },
            thickness: 1,
            color: rgb(0.8, 0.8, 0.8),
        })
        yOffset -= 30

        // Table header
        coverPage.drawText("#", { x: 50, y: yOffset, size: 12, font: helveticaBold, color: rgb(0.4, 0.4, 0.4) })
        coverPage.drawText("Song", { x: 80, y: yOffset, size: 12, font: helveticaBold, color: rgb(0.4, 0.4, 0.4) })
        coverPage.drawText("Key", { x: 400, y: yOffset, size: 12, font: helveticaBold, color: rgb(0.4, 0.4, 0.4) })
        yOffset -= 20

        // Table rows - list all songs
        tracks.forEach((track, index) => {
            if (yOffset < 50) return // Don't overflow page

            const num = `${index + 1}.`
            const songTitle = track.title.length > 45 ? track.title.substring(0, 42) + "..." : track.title
            const key = track.key || "-"

            coverPage.drawText(num, { x: 50, y: yOffset, size: 11, font: helvetica, color: rgb(0, 0, 0) })
            coverPage.drawText(songTitle, { x: 80, y: yOffset, size: 11, font: helvetica, color: rgb(0, 0, 0) })
            coverPage.drawText(key, { x: 400, y: yOffset, size: 11, font: helveticaBold, color: rgb(0.2, 0.4, 0.8) })

            yOffset -= 18
        })

        // Footer on cover page
        coverPage.drawText(`${tracks.length} songs â€¢ Generated by CRC Music Books`, {
            x: 50,
            y: 30,
            size: 10,
            font: helvetica,
            color: rgb(0.6, 0.6, 0.6),
        })

        // 3. Fetch and append each PDF file
        let appendedCount = 0
        for (const track of tracks) {
            if (!track.fileId) continue

            try {
                console.log(`Fetching PDF for: ${track.title} (${track.fileId})`)

                const fileBuffer = await drive.getFile(track.fileId)

                if (fileBuffer && fileBuffer instanceof ArrayBuffer && fileBuffer.byteLength > 0) {
                    try {
                        const pdfBytes = new Uint8Array(fileBuffer)
                        const sourcePdf = await PDFDocument.load(pdfBytes, { ignoreEncryption: true })
                        const pages = await mergedPdf.copyPages(sourcePdf, sourcePdf.getPageIndices())

                        pages.forEach(page => {
                            mergedPdf.addPage(page)
                        })

                        appendedCount++
                        console.log(`Appended ${pages.length} pages for: ${track.title}`)
                    } catch (pdfError) {
                        console.error(`PDF parse error for ${track.title}:`, pdfError)
                        // Skip this file but continue with others
                    }
                }
            } catch (fetchError) {
                console.error(`Failed to fetch ${track.title}:`, fetchError)
                // Skip this file but continue with others
            }
        }

        console.log(`Successfully appended ${appendedCount} PDF files`)

        // 4. Generate final PDF
        const finalPdfBytes = await mergedPdf.save()

        // 5. Return as downloadable PDF (convert Uint8Array to Buffer for NextResponse)
        const pdfBuffer = Buffer.from(finalPdfBytes)

        return new NextResponse(pdfBuffer, {
            headers: {
                'Content-Type': 'application/pdf',
                'Content-Disposition': `attachment; filename="${title.replace(/[^a-z0-9]/gi, '_')}.pdf"`,
            },
        })

    } catch (error: any) {
        console.error("Print generation error:", error)
        return NextResponse.json({
            error: "Failed to generate PDF",
            details: error.message
        }, { status: 500 })
    }
}
